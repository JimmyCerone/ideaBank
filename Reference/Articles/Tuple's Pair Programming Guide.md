Wow. So so much in here. Wish I'd had it when I started at [[Atomic Object]]. 

## Structure
- Pairing Styles
	- Ping Pong
		- One person writes a failing test the other gets it to pass then vice versa
	- Driver/Navigator
		- What Atomic uses
	- Strong Style
		- No one types their own ideas, it must go through someone else's hands. 
- This structure got me in particular:
	1.  \[ \] Agree on the high-level goal out loud.
	2.  \[ \] Break the work into a handful of tasks and prioritize them.
	3.  \[ \] Decide your driver/navigator swapping strategy.
	4.  \[ \] Configure git to share credit.
	5.  \[ \] Eliminate distractions.
	6.  \[ \] Work.
	7.  \[ \] Analyze the session with a mini retro.

I would love to implement the above structure more often. Not sure I'm loving pragmatic pairing because of how often I get stuck and don't know what to do. I think doing step 2 would help me learn faster and step 3 would be super nice for helping me keep going longer. Why doesn't [[Atomic Object]] do this? How can I get the support I need more often? 

Performing a mini retro would be so nice. Many of these ideas remind me of [[The Art of Gathering by Priya Parker]]. Once again I wonder why Atomic doesn't do this and how I could make it normal. There is so much switching and changing that I find it hard to establish a routine or schedule. 

I found this super helpful: 

### Antipatterns
For Navigators:
- Leaping on errors too quickly
- Giving low level instructions
- Not bringing a keyboard
For Drivers
- Driving too fast
- Allowing a checked out navigator
- Unequal screen access
- Not taking breaks
- Listening without hearing

For both
- Allowing unproductive distractions
- Not swapping roles
- Forgetting it's a skill

Source: https://tuple.app/pair-programming-guide/